<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>onlyhiphop的博客</title>
  
  <subtitle>Keep going!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/onlyhiphop/"/>
  <updated>2019-10-11T05:11:24.696Z</updated>
  <id>https://github.com/onlyhiphop/</id>
  
  <author>
    <name>onlyhiphop</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之动态代理</title>
    <link href="https://github.com/onlyhiphop/2019/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://github.com/onlyhiphop/2019/06/13/设计模式-动态代理/</id>
    <published>2019-06-13T15:55:36.000Z</published>
    <updated>2019-10-11T05:11:24.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式之动态代理"><a href="#设计模式之动态代理" class="headerlink" title="设计模式之动态代理"></a>设计模式之动态代理</h2><ul><li><p><a href="#1">一、什么是代理模式？</a></p></li><li><p><a href="#2">二、静态代理</a></p></li><li><p><a href="#3">三、动态代理</a></p></li><li><p><a href="#4">四、spring中的动态代理模式</a></p></li></ul><hr><h4 id="1">一、什么是代理模式？</h4>  ***1. 代理模式的定义：***<p>  为其他对象提供一种代理以控制对这个对象的访问。使用代理模式创建代理对象，让代理对象控制目标对象的访问(目标对象可以是远程的对象、创建开销大的对象或需要安全控制的对象),并且可以在不改变目标对象的情况下添加一些额外的功能。</p><p>  通俗的说，所谓代理，就是一个人或者一个机构代表另一个人或者另一个机构采取行动。在一些情况下，一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之前起到中介的作用</p><p>  <strong><em>2. 代理模式涉及到的角色：</em></strong></p><p>  （1）抽象角色：声明真实对象和代理对象的共同接口；可以是抽象类，也可以是接口，是一个最普通的业务类型定义，无特殊要求。</p><p>  （2）代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</p><p>  　　也叫委托类、代理类。它把所有抽象角色定义的方法给真实角色实现，并且在真实角色处理完毕前后做预处理和善后工作。（最简单的比如打印日志）（自己并未实现业务逻辑接口，而是调用真实角色来实现。）</p><p>  （3）真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。也叫被委托角色、被代理角色。是业务逻辑的具体执行者。（真正实现了业务逻辑接口。）</p><p><strong><em>示意图：</em></strong> <br><br><img src="/uploads/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/1.png" alt="design"></p><p>  <strong><em>3. 特征：</em></strong></p><p>  实现共同的接口以便于增强某个共有的方法，代理类拥有真实类的引用</p><h4 id="2">二、静态代理</h4>  ***1. 静态代理模式：***<p>  静态代理说白了就是在程序运行前就已经存在代理类的字节码文件，代理类和原始类的关系在运行前就已经确定。最大的特点就是在程序运行时代理类的.class文件就已经存在了，但是这有一个很大的缺陷即每一个代理类只能为一个接口服务。</p><p>  <strong><em>2. 静态代理案例：</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.staticProxy;</span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"模拟：保存用户！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"模拟：查询用户"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    静态代理</span></span><br><span class="line"><span class="comment">  特点：</span></span><br><span class="line"><span class="comment">  1. 目标对象必须要实现接口</span></span><br><span class="line"><span class="comment">  2. 代理对象，要实现与目标对象一样的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line">  <span class="comment">// 代理对象，需要维护一个目标对象</span></span><br><span class="line">  <span class="keyword">private</span> IUserDao target;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(IUserDao userDao)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.target = userDao;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"代理操作： 开启事务..."</span>);</span><br><span class="line">    target.save();   <span class="comment">// 执行目标对象的方法</span></span><br><span class="line">    System.out.println(<span class="string">"代理操作：提交事务..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    target.find();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        IUserDao userDao = <span class="keyword">new</span> UserDaoProxy(<span class="keyword">new</span> UserDao());</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong><em>3. 总结：</em></strong></p><p>  如果要按照上述的方式（静态代理）使用代理模式，那么真实角色必须是实现已经存在的，并将其作为代理对象的内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，大量使用静态代理会导致类的急剧膨胀；此外，如果事先并不知道真实角色，该如何使用代理呢？这个问题可以通过Java的动态代理类来解决。</p><h4 id="3">三、动态代理</h4>  ***1. 动态代理模式简介:***<p>  动态代理类（Proxy）的源码是在程序运行期间通过JVM反射等机制动态生成，代理类和委托类的关系是运行时才确定的。</p><p>  <strong><em>2. 动态代理模式两种创建方式:</em></strong></p><p>​            Foo是一个interface</p><p>  （1）getProxyClass()静态方法负责创建动态代理类，它的完整定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;[] interfaces) <span class="keyword">throws</span> IllegalArgumentException</span><br></pre></td></tr></table></figure><p>  <em>例子：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**** 方式一 ****/</span></span><br><span class="line"><span class="comment">//创建InvocationHandler对象</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(...);</span><br><span class="line"><span class="comment">//创建动态代理类</span></span><br><span class="line">Class proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123; Foo.class &#125;);</span><br><span class="line"><span class="comment">//创建动态代理类的实例</span></span><br><span class="line">Foo foo = (Foo) proxyClass.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler.class &#125;).newInstance(<span class="keyword">new</span> Object[] &#123; handler &#125;);</span><br></pre></td></tr></table></figure><p>参数loader 指定动态代理类的类加载器，参数interfaces 指定动态代理类需要实现的所有接口。</p><p><font color="red">由此可以知道：</font> 生成的代理类没有无参构造函数，只有一个拥有InvocationHandler参数的构造器，利用这个构造器给生成的代理类中的InvocationHandler属性赋值。</p><p>  （2）newProxyInstance()静态方法负责创建动态代理类的实例，它的完整定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler)</span> throws IllegalArgumentException</span></span><br></pre></td></tr></table></figure><p>  <em>CLassLoader loader:</em> 类的加载器 (指定动态代理类的类加载器)<br>  <em>Class&lt;?&gt;[] interfaces:</em> 得到全部的接口 (指定动态代理类需要实现的所有接口)<br>  <em>InvocationHandler h:</em> 得到InvocationHandler接口的子类的实例 (指定与动态代理类关联的 InvocationHandler 对象)</p><p><em>例子：</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**** 方式二 ****/</span></span><br><span class="line"><span class="comment">//创建InvocationHandler对象</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(...);</span><br><span class="line"><span class="comment">//直接创建动态代理类的实例</span></span><br><span class="line">Foo foo = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),<span class="keyword">new</span> Class[] &#123; Foo.class &#125;, handler);</span><br></pre></td></tr></table></figure><p><em>假定变量foo 是一个动态代理类的实例，并且这个动态代理类实现了Foo 接口，那么”foo instance of Foo”的值为true。把变量foo强制转换为Foo类型是合法的：(Foo) foo //合法</em><br><br><b><font color="red">但是要注意的是，这里的Foo是接口，强制转换时，必须使用接口，不能强制转换为某个实现类，如果使用Foo的实现类进行强制转换则会报错  java.lang.ClassCastException: com.sun.proxy.$Proxy13 cannot be cast to ….<br>因为JDK代理只能代理接口不能代理类，生成的代理类都是接口，具体的实现类在handler里面。</font><b></b></b></p><p>  <strong><em>3. 运用案例:</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***先创建需要动态代理的接口*****/</span></span><br><span class="line"><span class="keyword">public</span> interface TargetInterface &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***创建具体的实现类****/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span> <span class="title">implements</span> <span class="title">TargetInterface</span>&#123;</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***创建InvocationHandler对象****/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="title">implements</span> <span class="title">InvocationHandler</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意必须创建实现类的实例</span></span><br><span class="line">    <span class="keyword">private</span> Target target = <span class="keyword">new</span> Target();</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> throws Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"开始....."</span>);</span><br><span class="line">        method.invoke(target, args);  <span class="comment">//args表示用户执行传入的值</span></span><br><span class="line">        System.out.println(<span class="string">"结束....."</span>);</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***Main方法测试**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态生成的类支持强转</span></span><br><span class="line">        TargetInterface target = (TargetInterface) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> Class[]&#123;TargetInterface.class&#125;, <span class="keyword">new</span> MyInvocationHandler());</span><br><span class="line">        target.print(<span class="string">"执行业务...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***执行结果**/</span></span><br><span class="line">开始.....</span><br><span class="line">执行业务....</span><br><span class="line">结束.....</span><br></pre></td></tr></table></figure><p>  <strong><em>4. 总结:</em></strong></p><p>  <font color="red">所谓动态代理=动态编译+反射技术，就是通过用户传进来的接口去动态生成java类，在动态生成的java类中去组合InvocationHandler对象的引用，并在这个对象中的每个方法里都执行了InvocationHandler的invoke方法。这样就给外部提供了一个可变化的接口，用户就可以根据需要去实现InvocationHandler里面的invoke方法，从而实现动态的增加功能。</font></p><p> <strong><em>5. 补充:</em></strong></p><p>  但这里又引入一个问题,如果某个类没有实现接口,就不能使用JDK动态代理,所以Cglib代理就是解决这个问题的。<br>  Cglib是以动态生成的子类继承目标的方式实现，在运行期动态的在内存中构建一个子类</p><h4 id="4">四、spring中的动态代理模式</h4>**前文提到JDK代理和Cglib代理两种动态代理，优秀的Spring框架把两种方式在底层都集成了进去,我们无需担心自己去实现动态生成代理。那么，Spring是如何生成代理对象的？**<ol><li><p>创建容器对象的时候，根据切入点表达式拦截的类，生成代理对象。</p></li><li><p>如果目标对象有实现接口，使用jdk代理。如果目标对象没有实现接口，则使用Cglib代理。然后从容器获取代理后的对象，在运行期植入”切面”类的方法。通过查看Spring源码，我们在DefaultAopProxyFactory类中，找到这样一段话</p></li></ol><p><img src="/uploads/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/2.png" alt="img"></p><p>简单的从字面意思看出,如果有接口,则使用Jdk代理,反之使用Cglib，这刚好印证了前文所阐述的内容。Spring AOP综合两种代理方式的使用前提有会如下结论：<b><font color="red">如果目标类没有实现接口，且class为final修饰的，则不能进行Spring AOP编程！</font></b></p><p>APO：就是通过动态代理生成代理对象，对象里面再传入你需要增强的功能包装成的类（此类不需要和目标类实现一样的接口，可以是完全无关的类），这样就能实现在原来的功能上增加功能。</p><p><strong><em>那我们来手动实现一个AOP代理工厂类</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactoryBean</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要代理增强的类</span></span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line">  <span class="comment">//具体增强类，也就是需要添加的功能</span></span><br><span class="line">  <span class="keyword">private</span> Advice advice;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactoryBean</span><span class="params">(Object target, Advice advice)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="keyword">this</span>.advice = advice;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (target == null &amp;&amp; advice == null) &#123;</span><br><span class="line"><span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line">Object proxy = Proxy.newProxyInstance(</span><br><span class="line">target.getClass().getClassLoader(),</span><br><span class="line">target.getClass().getInterfaces(),</span><br><span class="line"><span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">advice.befforeMethod();</span><br><span class="line">Object retVal = method.invoke(target, args);</span><br><span class="line">advice.afterMethod();</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***增强功能类**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Advice</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">befforeMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"方法之前...."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"方法之后...."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***需要增强的类**/</span></span><br><span class="line"><span class="comment">/***必须实现一个接口*/</span></span><br><span class="line">interface TargetInterface&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span> <span class="title">implements</span> <span class="title">TargetInterface</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"执行业务...."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***测试**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ProxyFactoryBean fb = <span class="keyword">new</span> ProxyFactoryBean(<span class="keyword">new</span> Target(), <span class="keyword">new</span> Advice());</span><br><span class="line">    <span class="comment">//必须使用接口去强制转换，否则报错</span></span><br><span class="line">    TargetInterface ti = (TargetInterface)fb.getProxy();</span><br><span class="line">    ti.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***结果*/</span></span><br><span class="line">方法之前....</span><br><span class="line">执行业务....</span><br><span class="line">方法之后....</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设计模式之动态代理&quot;&gt;&lt;a href=&quot;#设计模式之动态代理&quot; class=&quot;headerlink&quot; title=&quot;设计模式之动态代理&quot;&gt;&lt;/a&gt;设计模式之动态代理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;一、什么是代理模式？&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://github.com/onlyhiphop/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design" scheme="https://github.com/onlyhiphop/tags/design/"/>
    
  </entry>
  
  <entry>
    <title>IDEA下Maven多模块开发</title>
    <link href="https://github.com/onlyhiphop/2019/06/11/IDEA%E4%B8%8BMaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/"/>
    <id>https://github.com/onlyhiphop/2019/06/11/IDEA下Maven多模块开发/</id>
    <published>2019-06-11T14:45:24.000Z</published>
    <updated>2019-06-27T05:54:55.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IDEA下Maven多模块开发"><a href="#IDEA下Maven多模块开发" class="headerlink" title="IDEA下Maven多模块开发"></a>IDEA下Maven多模块开发</h2><p>本教程将介绍如何使用IDEA进行Maven多模块工程开发。</p><ul><li><p><a href="#1">一、使用IDEA搭建Maven多模块工程</a></p></li><li><p><a href="#2">二、Maven中继承和聚合的关系</a></p></li><li><p><a href="#3">三、Maven的三种工程pom、jar、war的区别</a></p></li><li><p><a href="#4">四、在IDEA中创建pom，jar，war项目</a></p></li><li><p><a href="#5">五、Maven的三种工程实例</a></p></li></ul><hr><h4 id="1">一、使用IDEA搭建Maven多模块工程</h4><ol><li><p>首先，我们先来创建一个新的工作空间。 <br><br> File -&gt; New-Project -&gt; Empty Project <br><br> 点击Next，进行下一步</p></li><li><p>Project location：点击选择一个空文件夹，作为工作空间 <br><br> <font color="red" size="7">注意：路径不要有中文</font> <br><br> 点击Finish,进行下一步</p></li><li><p>现在工程打开的其实就是我们刚才创建的工作空间。</p></li><li><p>现在我们开始创建父工程.</p><p> File -&gt; Module  -&gt; Maven -&gt; Next <br><br> <strong>选择</strong> <br><br> <img src="/uploads/IDEA%E4%B8%8BMaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/1.png" alt="maven"></p><p> 直接点击Next</p></li><li><p>创建子工程pojo(打包方式为Jar) <br><br> File -&gt; Module  -&gt; Maven -&gt; Next <br><br> <strong>选择</strong> <br><br> <img src="/uploads/IDEA%E4%B8%8BMaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/2.png" alt="maven"></p></li><li><p>选择父工程，填写GroupId和ArtifactId和版本信息 <br><br> <img src="/uploads/IDEA%E4%B8%8BMaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/3.png" alt="maven"></p></li><li><p>现在我们能看到common.pom中已经继承了parent工程而parent工程中也聚合和common。 <br><br> <img src="/uploads/IDEA%E4%B8%8BMaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/4.png" alt="maven"><br> <img src="/uploads/IDEA%E4%B8%8BMaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/5.png" alt="maven"></p></li></ol><h4 id="2">二、Maven中继承和聚合的关系</h4><p>  <em>两者的目的是不一样的，聚合的目的是能够快速的构建项目，继承的目的是减少重复配置。</em></p><p><strong>1. 聚合</strong><br><br>定义一个聚合模块，然后在pom文件中添加&lt;module&gt;&lt;/module&gt;标签，其中的内容是模块相对于当前模块的路径。那么在构建聚合模块的时候，在&lt;module&gt;中定义的模块也会跟着构建，不用逐个构建，因此加快了构建速度。</p><p><strong>2. 继承</strong><br><br>除了定义一个父模块，在父模块的pom文件中添加&lt;module&gt;标签，还要在子模块pom文件中添加&lt;parent&gt;标签，指向父模块。指向之后，那么在父模块中定义的插件和依赖都可以被子模块继承，就不用再子模块pom文件中重复配置了（减少了重复配置）。<br><br><font color="red">注：无论是聚合还是继承，父模块的pom文件中的&lt;packageing&gt;的内容都是pom，（这是规定）。如果不写的话，默认的都是jar。</font></p><p><strong>3. 实际应用</strong><br><br>还有一个问题就是，在父模块定义了很多依赖，但是某一个模块并没有全部用到，那么子模块还是会全部继承过来。比较浪费。<br>所以可以使用依赖管理标签&lt;dependencyManagement&gt;<br>在父模块的pom文件中的&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;定义了所有需要依赖的jar包，但是这样子模块并不会引入这些jar包。子模块中需要哪些jar包就在自身pom文件的&lt;dependency&gt;标签中引入就可以了，因为父模块的pom文件中已经定义过了，子模块的pom文件只需定义出&lt;groupId&gt;和&lt;artifactId&gt;就可以了。</p><h4 id="3">三、Maven的三种工程pom、jar、war的区别</h4><pre><code>1.pom工程：用在父级工程或聚合工程中。用来做jar包的版本控制。- 打出来可以作为其他项目的maven依赖，在工程A中添加工程B的pom，A就可以使用B中的类。2.war工程：将会打包成war，发布在服务器上的工程。如网站或服务。3.jar工程：将会打包成jar用作jar包使用。</code></pre><p><font color="red">补充一下</font>，jdk9 后还可以打包 jmod（Java 模块化），厉害的是这个通过 jlink 命令，可以直接将 jmod 打包为对应环境的可执行的程序，告别了让用户安装 jdk 的步骤，现在也有对应的 maven 插件了</p><h4 id="4">四、在IDEA中创建pom，jar，war项目</h4><ol><li>创建java jar、pom项目时创建maven-archetype-quickstart</li><li>创建java war项目时创建maven-archetype-webapp</li></ol><p><img src="/uploads/IDEA%E4%B8%8BMaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/6.png" alt="maven"></p><h4 id="5">五、Maven的三种工程实例</h4><ul><li>以宜立方商城为例</li></ul><p><img src="/uploads/IDEA%E4%B8%8BMaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/7.png" alt="maven"></p><p><strong>1. pom工程</strong><br><br>    <strong>1.1 Tmallparent</strong> <br><br>      整个项目的父工程，它是一个pom工程。用来做整个项目的版本控制，也就是项目中所有要使用到的jar包的版本都集中由父工程管理。这样你在写其他工程pom文件中maven依赖时就不需要写版本号了。当然所有的项目都要先继承它才行。<br><br>    <strong>1.2 Tmallmanager</strong> <br><br>      用来做聚合工程，它也是一个pom工程。创建四个model分别是manager-dao 、manager-service、<br>      manager-interface、manager-pojo<br>      manager-web 同时会自动生成4个独立的maven工程。聚合工程只是用来帮助其他模块构建的工具，本身并没有实质的内容。具体每个工程代码的编写还是在生成的工程中去写</p><pre><code>&lt;font color=&quot;red&quot;&gt;pom工程的意义:&lt;/font&gt;原本这些模块也是一个个独立的工程，现在将它们聚合到Tmallmanager中，这样我们构建项目的时候就只要构建Tmallmanager一个就行了。我们只要使用maven构建这个聚合工程taotao-manager就行了而不用去操心模块的构建，比如install时只要install taotao-manager就行。总之就是简化操作。正常的编码工作还是在对应的manager-dao 、manager-service、manager-interface、manager-pojo工程中进行的。</code></pre><p><strong>2. war工程</strong></p><p>  <strong>Tmallmanager-web</strong> <br><br>  这些工程都是要部署在服务器上的，所以要打包成war形式。这些工程有的是用户通过浏览器直接访问，有的是通过发布服务被别的工程调用。</p><p><strong>3. jar工程</strong></p><p>  <strong>Tmallcommon</strong> <br><br>   这个就是打包成jar的工程。它就是存放一些其他工程都会使用的类，工具类。我们可以在其他工程的pom文件中去引用它，和引用别的jar包没什么区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IDEA下Maven多模块开发&quot;&gt;&lt;a href=&quot;#IDEA下Maven多模块开发&quot; class=&quot;headerlink&quot; title=&quot;IDEA下Maven多模块开发&quot;&gt;&lt;/a&gt;IDEA下Maven多模块开发&lt;/h2&gt;&lt;p&gt;本教程将介绍如何使用IDEA进行Ma
      
    
    </summary>
    
      <category term="Maven" scheme="https://github.com/onlyhiphop/categories/Maven/"/>
    
    
      <category term="maven" scheme="https://github.com/onlyhiphop/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>IDEA搭建Maven环境</title>
    <link href="https://github.com/onlyhiphop/2019/06/10/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/"/>
    <id>https://github.com/onlyhiphop/2019/06/10/IDEA搭建Maven环境/</id>
    <published>2019-06-10T15:48:46.000Z</published>
    <updated>2019-06-28T13:14:43.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IDEA搭建Maven环境"><a href="#IDEA搭建Maven环境" class="headerlink" title="IDEA搭建Maven环境"></a>IDEA搭建Maven环境</h2><p>本教程将介绍如何使用IDEA搭建Maven环境。</p><ul><li><p><a href="#1">一、使用idea创建maven项目</a></p></li><li><p><a href="#2">二、在idea中配置maven环境</a></p></li><li><p><a href="#3">三、settings.xml文件与配置</a></p></li><li><p><a href="#4">四、解决maven骨架问题（提高开发速度）</a></p></li><li><p><a href="#5">五、在idea中查看maven、冲突依赖、与修改pom.xml文件</a></p></li><li><p><a href="#6">六、maven的基本命令</a></p></li></ul><hr><h4 id="1">一、用idea创建maven web项目</h4><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/maven1.png" alt="maven"></p><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/maven2.png" alt="maven"></p><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/maven3.png" alt="maven"></p><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/maven4.png" alt="maven"></p><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/maven5.png" alt="maven"></p><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/maven6.png" alt="maven"></p><p><strong><em>这样就完成了在idea里创建maven项目、前提已经配置环境。</em></strong></p><h4 id="2">二、在idea中配置maven环境</h4><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/2maven1.png" alt="maven"></p><p><strong>打开Setings</strong></p><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/2maven2.png" alt="maven"></p><p><strong>加载本地maven骨架：-DarchetypeCatalog=local</strong></p><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/2maven2.png" alt="maven"></p><h4 id="3">三、settings.xml文件与配置</h4><ol><li>本地仓库</li></ol><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/3maven1.png" alt="maven"></p><ol start="2"><li>maven镜像（实际开发可能会搭建私服）</li></ol><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/3maven2.png" alt="maven"></p><h4 id="4">四、解决maven骨架问题（提高开发速度）</h4><ol><li><p>骨架（以后创建就很快、解决maven创建项目的速度问题）</p><p> 命令：-DarchetypeCatalog=local（指定加载本地骨架、上面已经配置好这个命令行）<br> 自己去官网下载一个maven骨架、就是下面这个文件！</p><p>archetype-catalog.xml</p><p><a href="http://repo1.maven.org/maven2/archetype-catalog.xml" target="_blank" rel="noopener">下载地址</a></p><p><a href="http://repo1.maven.org/maven2/archetype-catalog.xml/" target="_blank" rel="noopener">http://repo1.maven.org/maven2/archetype-catalog.xml/</a></p><p> Windows下：<br> 1.cmd<br> 2.start powershell<br> $client = new-object System.Net.WebClient<br> $client.DownloadFile(‘下载地址1’,’存储位置\文件名1.后缀’)</p></li><li><p>本地仓库地址</p><p> 本地：我们应该放在本地仓库的根路径下</p><p> 中央仓库：不设置、中央仓库下载、很慢很慢</p><p> 下载后放到哪里呢，这里与本地仓库的位置有关，假如本地仓库是maven默认的，并没有修改 那么就需要放到 C:\Users\del-berlin.m2\repository\org\apache\maven\archetype\archetype-catalog\2.4\下  ，本地仓库的默认位置：Default: ${user.home}/.m2/repository</p></li></ol><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/4maven1.png" alt="maven"></p><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/4maven2.png" alt="maven"></p><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/4maven3.png" alt="maven"></p><h4 id="5">五、在idea中查看maven、冲突依赖、与修改pom.xml文件</h4><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/5maven1.png" alt="maven"></p><p><img src="/uploads/IDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83/5maven2.png" alt="maven"></p><h4 id="6">六、maven的基本命令</h4><pre><code>mvn package 生成target目录，编译、测试代码，生成测试报告，生成jar/war文件mvn compile 编译mvn test 编译并测试mvn clean 清空生成的文件mvn site 生成项目相关信息的网站 mvn -e 显示详细错误 信息. mvn validate 验证工程是否正确，所有需要的资源是否可用。mvn test compile 编译项目测试代码。mvn test install 部署</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IDEA搭建Maven环境&quot;&gt;&lt;a href=&quot;#IDEA搭建Maven环境&quot; class=&quot;headerlink&quot; title=&quot;IDEA搭建Maven环境&quot;&gt;&lt;/a&gt;IDEA搭建Maven环境&lt;/h2&gt;&lt;p&gt;本教程将介绍如何使用IDEA搭建Maven环境。&lt;/
      
    
    </summary>
    
      <category term="Maven" scheme="https://github.com/onlyhiphop/categories/Maven/"/>
    
    
      <category term="maven" scheme="https://github.com/onlyhiphop/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>getResource方法的运用</title>
    <link href="https://github.com/onlyhiphop/2019/05/21/getResource%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%90%E7%94%A8/"/>
    <id>https://github.com/onlyhiphop/2019/05/21/getResource方法的运用/</id>
    <published>2019-05-21T13:12:24.000Z</published>
    <updated>2019-06-28T13:19:28.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="getResource方法的运用"><a href="#getResource方法的运用" class="headerlink" title="getResource方法的运用"></a>getResource方法的运用</h2><b>比如我们有以下目录<p>|–project</p><pre><code>|--src    |--javaapplication        |--Test.java        |--file1.txt    |--file2.txt|--build    |--javaapplication        |--Test.class        |--file3.txt    |--file4.txt</code></pre><p>首先讲file3.txt与file4.txt</p><p>file3.txt:</p><p>方法一：File file3 = new File(Test.class.getResource(“file3.txt”).getFile());</p><p>方法二：File file3 = new File(Test.class.getResource(“/javaapplication/file3.txt”).getFile());</p><p>方法三：File file3 = new File(Test.class.getClassLoader().getResource(“javaapplication/file3.txt”).getFile());</p><p>file4.txt:</p><p>方法一：File file4 = new File(Test.class.getResource(“/file4.txt”).getFile());</p><p>方法二：File file4 = new File(Test.class.getClassLoader().getResource(“file4.txt”).getFile());</p><p><font color="red">可以发现：<br><br>Test.class.getResource : 的根路径是 /  <br><br>Test.class.getClassLoader().getResource：的根路径是 “”<br></font></p><p>很好，我们可以有多种方法选择，但是file1与file2文件呢？如何获得？</p><p>答案是，你只能写上它们的绝对路径，不能像file3与file4一样用class.getResource()这种方法获得，它们的获取方法如下</p><p>假如整个project目录放在c:/下，那么file1与file2的获取方法分别为</p><p>file1.txt</p><p>方法一：File file1 = new File(“c:/project/src/javaapplication/file1.txt”);</p><p>方法二：。。。没有</p><p>file2.txt</p><p>方法一：File file2 = new File(“c:/project/src/file2.txt”);</p><p>方法二：。。。也没有</p><p>总结一下，就是你想获得文件，你得从最终生成的.class文件为着手点，不要以.java文件的路径为出发点，因为真正使用的就是.class，不会拿个.java文件就使用，因为java是编译型语言嘛<b></b></p></b>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;getResource方法的运用&quot;&gt;&lt;a href=&quot;#getResource方法的运用&quot; class=&quot;headerlink&quot; title=&quot;getResource方法的运用&quot;&gt;&lt;/a&gt;getResource方法的运用&lt;/h2&gt;&lt;b&gt;
比如我们有以下目录

&lt;p
      
    
    </summary>
    
      <category term="随笔" scheme="https://github.com/onlyhiphop/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://github.com/onlyhiphop/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>HTTP、Cookie、Session</title>
    <link href="https://github.com/onlyhiphop/2019/03/24/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://github.com/onlyhiphop/2019/03/24/HTTP协议详解/</id>
    <published>2019-03-23T17:32:24.000Z</published>
    <updated>2019-07-02T00:49:13.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP、Cookie、Session"><a href="#HTTP、Cookie、Session" class="headerlink" title="HTTP、Cookie、Session"></a>HTTP、Cookie、Session</h2><ul><li><p><a href="#1">一、HTTP消息结构</a></p></li><li><p><a href="#1">二、session与Cookie</a></p></li></ul><hr><font style="bolder"><h4 id="1">一、HTTP消息结构</h4><h5>1. 客户端请求消息</h5><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p><p><img src="/uploads/HTTP%E8%AF%A6%E8%A7%A3/1.png" alt="http"></p><p><b>实例：</b></p><p>GET请求</p><pre><code>GET /hello.html?name=liao&amp;passwd=123 HTTP/1.1User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3Host: www.example.comAccept-Language: en, mi</code></pre><p>POST请求</p><pre><code>POST /hello.html HTTP/1.1User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3Host: www.example.comAccept-Language: en, mi此处有空行name=liao&amp;passwd=123</code></pre><h5>2. 服务器响应消息</h5><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p><p><img src="/uploads/HTTP%E8%AF%A6%E8%A7%A3/2.jpg" alt="http"></p><p><b>实例：</b></p><pre><code>HTTP/1.1 200 OKDate: Mon, 27 Jul 2009 12:28:53 GMTServer: ApacheLast-Modified: Wed, 22 Jul 2009 19:15:56 GMTETag: &quot;34aa387-d-1568eb00&quot;Accept-Ranges: bytesContent-Length: 51Vary: Accept-EncodingContent-Type: text/plain</code></pre><h4 id="2">二、session与Cookie</h4><h5>1. Cookie</h5><p>Cookie实际上是一小段的文本信息。</p><p>客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客 户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务 器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p><p><img src="/uploads/HTTP%E8%AF%A6%E8%A7%A3/3.gif" alt="http"></p><p>Cookie对象使用key-value属性对的形式保存用户状态，一个Cookie对象保存一个属性对，一个request或者response同时使用多个Cookie</p><p><strong><em>Cookie的几个特点：</em></strong></p><p><strong>①：Cookie的不可跨域名性</strong><br>对于不同的域名会有对应的Cookie，Cookie是保存在客户端上由浏览器来管理，浏览器能保存只处理指定域名的Cookie，从而保证用户的隐私安全。</p><p><strong>例如:</strong><br><br>Google会向客户端颁发Cookie，Baidu也会向客户端颁发Cookie。那浏览器访问Google会不会也携带上Baidu颁发的Cookie呢？或者Google能不能修改Baidu颁发的Cookie呢？</p><p>答案是否定的。Cookie具有不可跨域名性。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。</p><p>Cookie在客户端是由浏览器来管理的。浏览器能够保证Google只会操作Google的Cookie而不会操作 Baidu的Cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站Cookie的依据是域名。Google与Baidu的域名 不一样，因此Google不能操作Baidu的Cookie。</p><p><font color="red">但是也有特殊的情况可以实现跨域</font><br><br>Cookie是不可跨域名的。域名<a href="http://www.google.com颁发的Cookie不会被提交到域名www.baidu.com去。这是由Cookie的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的Cookie。" target="_blank" rel="noopener">www.google.com颁发的Cookie不会被提交到域名www.baidu.com去。这是由Cookie的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的Cookie。</a></p><p>正常情况下，同一个一级域名下的两个二级域名如<a href="http://www.helloweenvsfei.com和" target="_blank" rel="noopener">www.helloweenvsfei.com和</a> images.helloweenvsfei.com也不能交互使用Cookie，因为二者的域名并不严格相同。如果想所有 helloweenvsfei.com名下的二级域名都可以使用该Cookie，需要设置Cookie的domain参数，例如：</p><pre><code>Cookie cookie = new Cookie(&quot;time&quot;,&quot;20080808&quot;); // 新建Cookiecookie.setDomain(&quot;.helloweenvsfei.com&quot;);           // 设置域名cookie.setPath(&quot;/&quot;);                              // 设置路径cookie.setMaxAge(Integer.MAX_VALUE);               // 设置有效期response.addCookie(cookie);                       // 输出到客户端</code></pre><p>读者可以修改本机C:\WINDOWS\system32\drivers\etc下的hosts文件来配置多个临时域名，然后使用setCookie.jsp程序来设置跨域名Cookie验证domain属性。</p><p>注意：domain参数必须以点(“.”)开始。另外，name相同但domain不同的两个Cookie是两个不同的Cookie。如果想要两个域名完全不同的网站共有Cookie，可以生成两个Cookie，domain属性分别为两个域名，输出到客户端。</p><p><font color="red">需要注意的是</font>虽然网站images.google.com与网站<a href="http://www.google.com同属于Google，但是域名不一样，二者同样不能互相操作彼此的Cookie。" target="_blank" rel="noopener">www.google.com同属于Google，但是域名不一样，二者同样不能互相操作彼此的Cookie。</a></p><p>注意：用户登录网站<a href="http://www.google.com之后会发现访问images.google.com时登录信息仍然有效，而普通的Cookie是做不到的。这是因为Google做了特殊处理。" target="_blank" rel="noopener">www.google.com之后会发现访问images.google.com时登录信息仍然有效，而普通的Cookie是做不到的。这是因为Google做了特殊处理。</a></p><p><strong><em>在java中cookie的引用：</em></strong> <br><br>Java中把Cookie封装成了javax.servlet.http.Cookie类。每个Cookie都是该Cookie类的对象。服务器通过操作Cookie类对象对客户端Cookie进行操作。通过request.getCookie()获取客户端提交的所有Cookie（以Cookie[]数组形式返回），通过response.addCookie(Cookiecookie)向客户端设置Cookie。</p><p>Cookie对象使用key-value属性对的形式保存用户状态，一个Cookie对象保存一个属性对，一个request或者response同时使用多个Cookie。因为Cookie类位于包javax.servlet.http.*下面，所以JSP中不需要import该类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="number">1.</span>状态cookie：状态cookie的特点是浏览器会将该对象保存在运行浏览器的进程中。</span><br><span class="line">他的生命周期是谁这浏览器的存在而存在，随着浏览器的消亡而消亡</span><br><span class="line"><span class="number">2.</span>持久化cookie：持久化cookie的特点是浏览器会将这个cookie对象持久化到磁盘中。</span><br><span class="line">当cookie设置时间到达时，浏览器就不会在请求中传递这个cookie了。</span><br><span class="line">对于保存cookie的文件 我们不需要管理。</span><br><span class="line">浏览器自己回来管理这些文件。</span><br><span class="line"></span><br><span class="line">     <span class="comment">//1.创建状态Cookie （一次性 保存在浏览器相关进程中，浏览器关闭就会消失）</span></span><br><span class="line">Cookie c=<span class="keyword">new</span> Cookie(<span class="string">"name"</span>, <span class="string">"value"</span>);</span><br><span class="line">     <span class="comment">//key和value都是String类型的 但不能有中文，内部默认编码是ISO-8859-1</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//2.创建持久化Cookie(设置时间的 单位为秒  不会随着你浏览器的关闭而消失，他是以文档形式存放在磁盘上的)</span></span><br><span class="line">c.setMaxAge(<span class="number">120</span>);  <span class="comment">//c.setMaxAge(60*60*24*365);  一年</span></span><br><span class="line"></span><br><span class="line">     response.addCookie(cookie);                    <span class="comment">// 输出到客户端</span></span><br></pre></td></tr></table></figure><p><strong><em>Cookie的修改、删除</em></strong><br>Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。</p><p>如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。</p><pre><code>Cookie cookie = new Cookie(&quot;username&quot;,&quot;helloweenvsfei&quot;);   // 新建Cookiecookie.setMaxAge(0);                          // 设置生命周期为0，不能为负数response.addCookie(cookie);                    // 必须执行这一句</code></pre><p><font color="red">注意：</font>修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。</p><p><strong>②：Cookie的有效性</strong><br>Cookie的maxAge决定着Cookie的有效期，单位为秒。<br>客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。 另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。<br>以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。</p><p><strong><em>③：Cookie的安全属性</em></strong></p><p>HTTP协议不仅是无状态的，而且是不安全的。使用HTTP协议的数据不经过任何加密就直接在网络上传播，有被截获的可 能。使用HTTP协议传输很机密的内容是一种隐患。如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的secure属性为 true。浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie。下面的代码设置secure属性为true：</p><pre><code>Cookie cookie = new Cookie(&quot;time&quot;, &quot;20080808&quot;); // 新建Cookiecookie.setSecure(true);                           // 设置安全属性response.addCookie(cookie);                        // 输出到客户端</code></pre><p>提示：secure属性并不能对Cookie内容加密，因而不能保证绝对的安全性。如果需要高安全性，需要在程序中对Cookie内容加密、解密，以防泄密。</p><h5>2. Session</h5><p>除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。</p><p><strong><em>什么是Session?</em></strong></p><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p><p>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP、Cookie、Session&quot;&gt;&lt;a href=&quot;#HTTP、Cookie、Session&quot; class=&quot;headerlink&quot; title=&quot;HTTP、Cookie、Session&quot;&gt;&lt;/a&gt;HTTP、Cookie、Session&lt;/h2&gt;&lt;ul&gt;

      
    
    </summary>
    
      <category term="网络编程" scheme="https://github.com/onlyhiphop/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="https://github.com/onlyhiphop/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
