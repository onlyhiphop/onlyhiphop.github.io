<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式之动态代理]]></title>
    <url>%2F2019%2F06%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[设计模式之动态代理本教程将介绍如何使用IDEA进行Maven多模块工程开发。 一、什么是代理模式？ 二、静态代理 三、动态代理 四、spring中的动态代理模式 一、什么是代理模式？ 1. 代理模式的定义： 为其他对象提供一种代理以控制对这个对象的访问。使用代理模式创建代理对象，让代理对象控制目标对象的访问(目标对象可以是远程的对象、创建开销大的对象或需要安全控制的对象),并且可以在不改变目标对象的情况下添加一些额外的功能。 通俗的说，所谓代理，就是一个人或者一个机构代表另一个人或者另一个机构采取行动。在一些情况下，一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之前起到中介的作用 2. 代理模式涉及到的角色： （1）抽象角色：声明真实对象和代理对象的共同接口；可以是抽象类，也可以是接口，是一个最普通的业务类型定义，无特殊要求。 （2）代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 也叫委托类、代理类。它把所有抽象角色定义的方法给真实角色实现，并且在真实角色处理完毕前后做预处理和善后工作。（最简单的比如打印日志）（自己并未实现业务逻辑接口，而是调用真实角色来实现。） （3）真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。也叫被委托角色、被代理角色。是业务逻辑的具体执行者。（真正实现了业务逻辑接口。） 示意图： 3. 特征： 实现共同的接口以便于增强某个共有的方法，代理类拥有真实类的引用 二、静态代理 1. 静态代理模式： 静态代理说白了就是在程序运行前就已经存在代理类的字节码文件，代理类和原始类的关系在运行前就已经确定。最大的特点就是在程序运行时代理类的.class文件就已经存在了，但是这有一个很大的缺陷即每一个代理类只能为一个接口服务。 2. 静态代理案例： 12345678910111213141516171819202122232425262728293031323334353637package test.staticProxy;// 接口public interface IUserDao &#123; void save(); void find();&#125;//目标对象class UserDao implements IUserDao&#123; @Override public void save() &#123; System.out.println("模拟：保存用户！"); &#125; @Override public void find() &#123; System.out.println("模拟：查询用户"); &#125;&#125;/** 静态代理 特点： 1. 目标对象必须要实现接口 2. 代理对象，要实现与目标对象一样的接口 */class UserDaoProxy implements IUserDao&#123; // 代理对象，需要维护一个目标对象 private IUserDao target = new UserDao(); @Override public void save() &#123; System.out.println("代理操作： 开启事务..."); target.save(); // 执行目标对象的方法 System.out.println("代理操作：提交事务..."); &#125; @Override public void find() &#123; target.find(); &#125;&#125; 3. 总结： 如果要按照上述的方式（静态代理）使用代理模式，那么真实角色必须是实现已经存在的，并将其作为代理对象的内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，大量使用静态代理会导致类的急剧膨胀；此外，如果事先并不知道真实角色，该如何使用代理呢？这个问题可以通过Java的动态代理类来解决。 三、动态代理 1. 动态代理模式简介: 动态代理类（Proxy）的源码是在程序运行期间通过JVM反射等机制动态生成，代理类和委托类的关系是运行时才确定的。 2. 动态代理模式创建方式: （1）getProxyClass()静态方法负责创建动态代理类，它的完整定义如下： 1public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;[] interfaces) throws IllegalArgumentException 例子： 1234567/**** 方式一 ****///创建InvocationHandler对象InvocationHandler handler = new MyInvocationHandler(...);//创建动态代理类Class proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), new Class[] &#123; Foo.class &#125;);//创建动态代理类的实例Foo foo = (Foo) proxyClass.getConstructor(new Class[] &#123; InvocationHandler.class &#125;).newInstance(new Object[] &#123; handler &#125;); 参数loader 指定动态代理类的类加载器，参数interfaces 指定动态代理类需要实现的所有接口。 由此可以知道： 生成的代理类没有无参构造函数，只有一个拥有InvocationHandler参数的构造器，利用这个构造器给生成的代理类中的InvocationHandler属性赋值。 （2）newProxyInstance()静态方法负责创建动态代理类的实例，它的完整定义如下： 1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler) throws IllegalArgumentException CLassLoader loader: 类的加载器 (指定动态代理类的类加载器) Class&lt;?&gt;[] interfaces: 得到全部的接口 (指定动态代理类需要实现的所有接口) InvocationHandler h: 得到InvocationHandler接口的子类的实例 (指定与动态代理类关联的 InvocationHandler 对象) 例子： 12345/**** 方式二 ****///创建InvocationHandler对象InvocationHandler handler = new MyInvocationHandler(...);//直接创建动态代理类的实例Foo foo = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),new Class[] &#123; Foo.class &#125;, handler); 假定变量foo 是一个动态代理类的实例，并且这个动态代理类实现了Foo 接口，那么”foo instance of Foo”的值为true。把变量foo强制转换为Foo类型是合法的：(Foo) foo //合法但是要注意的是，这里的Foo是接口，强制转换时，必须使用接口，不能强制转换为某个实现类，如果使用Foo的实现类进行强制转换则会报错 java.lang.ClassCastException: com.sun.proxy.$Proxy13 cannot be cast to ….因为JDK代理只能代理接口不能代理类，生成的代理类都是接口，具体的实现类在handler里面。 3. 运用案例: 12345678910111213141516171819202122232425262728293031323334353637383940/***先创建需要动态代理的接口*****/public interface TargetInterface &#123; void print(String str);&#125;/***创建具体的实现类****/class Target implements TargetInterface&#123; @Override public void print(String str) &#123; System.out.println(str); &#125;&#125;/***创建InvocationHandler对象****/class MyInvocationHandler implements InvocationHandler &#123; //注意必须创建实现类的实例 private Target target = new Target(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("开始....."); method.invoke(target, args); //args表示用户执行传入的值 System.out.println("结束....."); return null; &#125;&#125;/***Main方法测试**/class Main &#123; public static void main(String[] args) &#123; //动态生成的类支持强转 TargetInterface target = (TargetInterface) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;TargetInterface.class&#125;, new MyInvocationHandler()); target.print("执行业务...."); &#125;&#125;/***执行结果**/开始.....执行业务....结束..... 4. 总结: 所谓动态代理=动态编译+反射技术，就是通过用户传进来的接口去动态生成java类，在动态生成的java类中去组合InvocationHandler对象的引用，并在这个对象中的每个方法里都执行了InvocationHandler的invoke方法。这样就给外部提供了一个可变化的接口，用户就可以根据需要去实现InvocationHandler里面的invoke方法，从而实现动态的增加功能。 5. 补充: 但这里又引入一个问题,如果某个类没有实现接口,就不能使用JDK动态代理,所以Cglib代理就是解决这个问题的。 Cglib是以动态生成的子类继承目标的方式实现，在运行期动态的在内存中构建一个子类 四、spring中的动态代理模式 前文提到JDK代理和Cglib代理两种动态代理，优秀的Spring框架把两种方式在底层都集成了进去,我们无需担心自己去实现动态生成代理。那么，Spring是如何生成代理对象的？ 创建容器对象的时候，根据切入点表达式拦截的类，生成代理对象。 如果目标对象有实现接口，使用jdk代理。如果目标对象没有实现接口，则使用Cglib代理。然后从容器获取代理后的对象，在运行期植入”切面”类的方法。通过查看Spring源码，我们在DefaultAopProxyFactory类中，找到这样一段话 简单的从字面意思看出,如果有接口,则使用Jdk代理,反之使用Cglib，这刚好印证了前文所阐述的内容。Spring AOP综合两种代理方式的使用前提有会如下结论：如果目标类没有实现接口，且class为final修饰的，则不能进行Spring AOP编程！ APO：就是通过动态代理生成代理对象，对象里面再传入你需要增强的功能包装成的类（此类不需要和目标类实现一样的接口，可以是完全无关的类），这样就能实现在原来的功能上增加功能。 那我们来手动实现一个AOP代理工厂类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class ProxyFactoryBean &#123; //需要代理增强的类 private Object target; //具体增强类，也就是需要添加的功能 private Advice advice; public ProxyFactoryBean(Object target, Advice advice)&#123; this.target = target; this.advice = advice; &#125; public Object getProxy()&#123; if (target == null &amp;&amp; advice == null) &#123; return null; &#125; Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // TODO Auto-generated method stub advice.befforeMethod(); Object retVal = method.invoke(target, args); advice.afterMethod(); return retVal; &#125; &#125;); return proxy; &#125;&#125;/***增强功能类**/class Advice&#123; public void befforeMethod()&#123; System.out.println("方法之前...."); &#125; public void afterMethod()&#123; System.out.println("方法之后...."); &#125;&#125;/***需要增强的类**//***必须实现一个接口*/interface TargetInterface&#123; void print();&#125;class Target implements TargetInterface&#123; public void print()&#123; System.out.println("执行业务...."); &#125;&#125;/***测试**/class Main&#123; public static void main(String[] args)&#123; ProxyFactoryBean fb = new ProxyFactoryBean(new Target(), new Advice()); //必须使用接口去强制转换，否则报错 TargetInterface ti = (TargetInterface)fb.getProxy(); ti.print(); &#125;&#125;/***结果*/方法之前....执行业务....方法之后....]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA下Maven多模块开发]]></title>
    <url>%2F2019%2F06%2F11%2FIDEA%E4%B8%8BMaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[IDEA下Maven多模块开发本教程将介绍如何使用IDEA进行Maven多模块工程开发。 一、使用IDEA搭建Maven多模块工程 二、Maven中继承和聚合的关系 三、Maven的三种工程pom、jar、war的区别 四、在IDEA中创建pom，jar，war项目 五、Maven的三种工程实例 一、使用IDEA搭建Maven多模块工程 首先，我们先来创建一个新的工作空间。 File -&gt; New-Project -&gt; Empty Project 点击Next，进行下一步 Project location：点击选择一个空文件夹，作为工作空间 注意：路径不要有中文 点击Finish,进行下一步 现在工程打开的其实就是我们刚才创建的工作空间。 现在我们开始创建父工程. File -&gt; Module -&gt; Maven -&gt; Next 选择 直接点击Next 创建子工程pojo(打包方式为Jar) File -&gt; Module -&gt; Maven -&gt; Next 选择 选择父工程，填写GroupId和ArtifactId和版本信息 现在我们能看到common.pom中已经继承了parent工程而parent工程中也聚合和common。 二、Maven中继承和聚合的关系 两者的目的是不一样的，聚合的目的是能够快速的构建项目，继承的目的是减少重复配置。 1. 聚合定义一个聚合模块，然后在pom文件中添加&lt;module&gt;&lt;/module&gt;标签，其中的内容是模块相对于当前模块的路径。那么在构建聚合模块的时候，在&lt;module&gt;中定义的模块也会跟着构建，不用逐个构建，因此加快了构建速度。 2. 继承除了定义一个父模块，在父模块的pom文件中添加&lt;module&gt;标签，还要在子模块pom文件中添加&lt;parent&gt;标签，指向父模块。指向之后，那么在父模块中定义的插件和依赖都可以被子模块继承，就不用再子模块pom文件中重复配置了（减少了重复配置）。注：无论是聚合还是继承，父模块的pom文件中的&lt;packageing&gt;的内容都是pom，（这是规定）。如果不写的话，默认的都是jar。 3. 实际应用还有一个问题就是，在父模块定义了很多依赖，但是某一个模块并没有全部用到，那么子模块还是会全部继承过来。比较浪费。所以可以使用依赖管理标签&lt;dependencyManagement&gt;在父模块的pom文件中的&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;定义了所有需要依赖的jar包，但是这样子模块并不会引入这些jar包。子模块中需要哪些jar包就在自身pom文件的&lt;dependency&gt;标签中引入就可以了，因为父模块的pom文件中已经定义过了，子模块的pom文件只需定义出&lt;groupId&gt;和&lt;artifactId&gt;就可以了。 三、Maven的三种工程pom、jar、war的区别 1.pom工程：用在父级工程或聚合工程中。用来做jar包的版本控制。 - 打出来可以作为其他项目的maven依赖，在工程A中添加工程B的pom，A就可以使用B中的类。 2.war工程：将会打包成war，发布在服务器上的工程。如网站或服务。 3.jar工程：将会打包成jar用作jar包使用。补充一下，jdk9 后还可以打包 jmod（Java 模块化），厉害的是这个通过 jlink 命令，可以直接将 jmod 打包为对应环境的可执行的程序，告别了让用户安装 jdk 的步骤，现在也有对应的 maven 插件了 四、在IDEA中创建pom，jar，war项目 创建java jar、pom项目时创建maven-archetype-quickstart 创建java war项目时创建maven-archetype-webapp 五、Maven的三种工程实例 以宜立方商城为例 1. pom工程 1.1 Tmallparent 整个项目的父工程，它是一个pom工程。用来做整个项目的版本控制，也就是项目中所有要使用到的jar包的版本都集中由父工程管理。这样你在写其他工程pom文件中maven依赖时就不需要写版本号了。当然所有的项目都要先继承它才行。 1.2 Tmallmanager 用来做聚合工程，它也是一个pom工程。创建四个model分别是manager-dao 、manager-service、 manager-interface、manager-pojo manager-web 同时会自动生成4个独立的maven工程。聚合工程只是用来帮助其他模块构建的工具，本身并没有实质的内容。具体每个工程代码的编写还是在生成的工程中去写 &lt;font color=&quot;red&quot;&gt;pom工程的意义:&lt;/font&gt; 原本这些模块也是一个个独立的工程，现在将它们聚合到Tmallmanager中，这样我们构建项目的时候就只要构建Tmallmanager一个就行了。我们只要使用maven构建这个聚合工程taotao-manager就行了而不用去操心模块的构建，比如install时只要install taotao-manager就行。总之就是简化操作。正常的编码工作还是在对应的manager-dao 、manager-service、manager-interface、manager-pojo工程中进行的。2. war工程 Tmallmanager-web 这些工程都是要部署在服务器上的，所以要打包成war形式。这些工程有的是用户通过浏览器直接访问，有的是通过发布服务被别的工程调用。 3. jar工程 Tmallcommon 这个就是打包成jar的工程。它就是存放一些其他工程都会使用的类，工具类。我们可以在其他工程的pom文件中去引用它，和引用别的jar包没什么区别。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA搭建Maven环境]]></title>
    <url>%2F2019%2F06%2F10%2FIDEA%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[IDEA搭建Maven环境本教程将介绍如何使用Maven在intellijIDEA中使用等、开发语言Java。 一、使用idea创建maven项目 二、在idea中配置maven环境 三、settings.xml文件与配置 四、解决maven骨架问题（提高开发速度） 五、在idea中查看maven、冲突依赖、与修改pom.xml文件 六、maven的基本命令 一、用idea创建maven web项目 这样就完成了在idea里创建maven项目、前提已经配置环境。 二、在idea中配置maven环境 打开Setings 加载本地maven骨架：-DarchetypeCatalog=local 三、settings.xml文件与配置 本地仓库 maven镜像（实际开发可能会搭建私服） 四、解决maven骨架问题（提高开发速度） 骨架（以后创建就很快、解决maven创建项目的速度问题） 命令：-DarchetypeCatalog=local（指定加载本地骨架、上面已经配置好这个命令行） 自己去官网下载一个maven骨架、就是下面这个文件！ archetype-catalog.xml 下载地址 http://repo1.maven.org/maven2/archetype-catalog.xml/ Windows下： 1.cmd 2.start powershell $client = new-object System.Net.WebClient $client.DownloadFile(‘下载地址1’,’存储位置\文件名1.后缀’) 本地仓库地址 本地：我们应该放在本地仓库的根路径下 中央仓库：不设置、中央仓库下载、很慢很慢 下载后放到哪里呢，这里与本地仓库的位置有关，假如本地仓库是maven默认的，并没有修改 那么就需要放到 C:\Users\del-berlin.m2\repository\org\apache\maven\archetype\archetype-catalog\2.4\下 ，本地仓库的默认位置：Default: ${user.home}/.m2/repository 五、在idea中查看maven、冲突依赖、与修改pom.xml文件 六、maven的基本命令 mvn package 生成target目录，编译、测试代码，生成测试报告，生成jar/war文件 mvn compile 编译 mvn test 编译并测试 mvn clean 清空生成的文件 mvn site 生成项目相关信息的网站 mvn -e 显示详细错误 信息. mvn validate 验证工程是否正确，所有需要的资源是否可用。 mvn test compile 编译项目测试代码。 mvn test install 部署]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
</search>
